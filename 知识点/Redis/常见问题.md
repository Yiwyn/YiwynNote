### <font color='red'>Redis为什么这么快</font>



- #### 完全基于内存，绝大部分请求时纯粹的内存操作，非常快速。类似于HashMap，HashMap的优势是查询和操作的时间复杂度都是O(1)

- #### 数据结构简单，对数据的操作也简单。

- #### 采用单线程，避免不必要的上下文切换和竞争条件。

- #### 多路I/O服用模型，非阻塞IO







### <font color='red'>数据库与缓存不一致</font>



- #### redis是缓存，更倾向于稍微的时差。

- #### 以减少数据库操作为主





### <font color='red'>主从不一致的问题</font>



- #### redis默认是弱一致性，异步的同步

- #### 锁不能用主从（单实例/分片集群/redlock）==> redisson

- #### 在配置中提供了必须有多少个Client连接能同步，可以设置同步因子，趋向于强制一性





### <font color='red'>redis持久化方式</font>



- #### RDB、AOF；主从同步也算持久性

- #### 高版本：开启AOF，AOF可以通过执行日志得到全部内存数据的方式，但是追求性能：

  - ##### 体积变大，重复无效指令  重写后台哟个线程把内存的kv生成指令写个新的AOF

  - ##### 4.x版本之后，新增更有性能模式：把重写方式换成直接RDB放到AOF文件的头部







### <font color='red'>redis持久化原理</font>



- #### 异步后台进程完成持久化

  - ##### fork + cow







### <font color='red'>redis实现分布式锁</font>



- #### 要用分布式锁，就要用 set k v nx ex（不存在，过期时间，避免死锁）

