## <font color='red'>InnoDB中索引的推演</font>





## 1.1索引之前的查找

先看一个精确匹配的例子：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = XXX;
```

### 1、在一个数据页中的查找

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

 以主键为搜索条件

 可以在页目录中使用`二分法`快速定位到对应的槽，然后再便利该槽对应分组中的记录即可快速找到指定的记录。

 以其它列作为搜索条件

 因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从`最小记录`开始`依次遍历`单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

### 2、在很多数据页中查找

大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤:

 1、定位到记录所在的数据页；

 2、从所在的页内中查找相应的记录。

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从`第一个页`沿着`双向链表`一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是`超级耗时`的。如果一个表有一亿条记录呢?此时索引应运而生。

## 1.2设计索引

建一个表：

```sql
mysql> CREATE TABLE index_demo(
	-> c1 INT,
    -> C2 INT,
    -> C3 CHAR(1),
    -> PRIMARY KEY(C1)
) ROW_FORMAT = Compact;
```

该表的行格式简化图如下所示
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113832166-910831246.png)

`record_type`:记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1表示目录项的记录。
`next_record` :记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。
`各个列的值`:这里只记录在index_demo表中的三个列，分别是c1、c2和c3。
`其他信息`∶除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

把一些记录放到页中的示意图就是：
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113838523-3512408.png)

### 1、一个简单的索引设计方案

我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢?因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想`快速的定位到需要查找的记录在哪些数据页中`该咋办?我们可以为快速定位记录所在的数据页而`建立一个目录`，建这个目录必须完成下边这些事:

 **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**

 假设:每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录)。有了这个假设之后我们向`index_demo`表插入3条记录:

```sql
mysql> INSERT INTO index_demo VALUES(1, 4, 'U'), (3, 9, 'd'), (5, 3, 'y');
```

那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113851392-1423251820.png)

从图中可以看出来, `index_demo`表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入—条记录:

```sql
mysql> INSET INTO index_demo VALUES(4, 4, 'a');
```

因为页10最多只能放3跳记录，所以我们不得不再分配一个新页：
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113901036-2067372135.png)

注意，新分配的`数据页编号`可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了`链表`关系。另外，`页10`中用户记录最大的主键值是`5`，而`页28`中有一条记录的主键值是`4`，因为`5>4`，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次`记录移动`，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下:
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113909271-1333614361.png)

这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如`记录移动`的操作来始终保证这个状态一直成立:下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们称为`页分裂`。

**给所有的页建立一个目录项**

由于数据页的编号可能是不连续的，所以在向index_demo表中插入许多条记录后，可能是这样的效果:
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113918011-867605042.png)

因为这些`16KB`的页在物理存储上是不连续的，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分:

 页的用户记录中最小的主键值，我们用`key`来表示。

 页号。我们用`page_no`表示。

所以我们为上边几个页做好的目录就像这样：
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113927778-204041307.png)

以`页28`为例，它对应`目录项2`，这个目录项中包含着该页的页号`28`以及该页中用户记录的最小主键值`5`。我们只需要把几个目录项在物理存储器上连续存储（比如:数组)，就可以实现根据主键值快速查找某条记录的功能了。比如:查找主键值为`20`的记录，具体查找过程分两步:

 1、先从目录项中根据`二分法`快速确定出主键值为`20`的记录在`目录项3`中(因为 `12< 20 < 209`)，它对应的页是`页9`。

 2、再根据前边说的在页中查找记录的方式去`页9`中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为`索引`。

### 2、InnoDB中的索引方案

#### ①迭代一次：目录项记录的页

上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用`二分法`快速定位具体的目录项而`假设`所有目录项都可以在物理存储器上`连续存储`，但是这样做有几个问题:

● InnoDB是使用页来作为管理存储空间的基本单位，最多能保证`16KB`的连续存储空间，而随着表中记录数量的增多，需要`非常大的连续的存储空间`才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。

● 我们时常会对记录进行`增删`，假设我们把`页28`中的记录都删除了，那意味着`目录项2`也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。

所以，我们需要一种可以`灵活管理所有目录项`的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是`主键`和`页号`而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为`目录项记录`。那InnoDB怎么区分一条记录是普通的`用户记录`还是`目录项记录`呢?使用记录头信息里的
record_type属性，它的各个取值代表的意思如下:
● 0∶普通的用户记录
● 1∶目录项记录
● 2 : 最小记录
● 3∶最大记录
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113937157-2100935570.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调`目录项记录`和普通的`用户记录`的**不同点**:

● `目录项记录`的`record_type`值是1，而`普通用户记录`的`record_type`值是o。
● 目录项记录只有`主键值和页的编号`两个列，而普通的用户记录的列是用户自己定义的，可能包含`很多列`，另外还有InnoDB自己添加的隐藏列。
● 了解:记录头信息里还有一个叫`min_rec_mask` 的属性，只有在存储`目录项记录`的页中的主键值最小的`目录项记录`的`min_rec_mask`值为1，其他别的记录的`min_rec_mask`值都是0。

**相同点**：两者用的是一样的数据页，都会为主键值生成`Page Directory` (页目录)，从而在按照主键值进行查找时可以使用`二分法`来加快查询速度。

现在以查找主键为20的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步:

 1、先到存储`目录项记录`的页，也就是页30中通过`二分法`快速定位到对应目录项，因为`12 < 20 < 209`，所以定位到对应的记录所在的页就是页9。

 2、再到存储用户记录的页9中根据`二分法`快速定位到主键值为`20`的用户记录。

#### ②迭代2次：多个目录项记录的页

虽然说`目录项记录`中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有`16KB`大小，能存放的`目录项记录`也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的`目录项记录`，如何处理呢?

这里我们假设一个存储目录项记录的页`最多只能存放4条目录项记录`，所以如果此时我们再向上图中插入一条主键值为320的用户记录的话，那就需要分配一个新的存储`目录项记录`的页:
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113946214-1887453971.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页:

● 为存储该用户记录而新生成了`页31`。
● 因为原先存储目录项记录的`页30的容量已满`(我们前边假设只能存储4条目录项记录)，所以不得不需要一个新的`页32`来存放`页31`对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为20的记录为例:

1、确定`目录项记录页`

我们现在的存储目录项记录的页有两个，即`页30`和`页32`，又因为页30表示的目录项的主键值的范围是`[1,320)`，页32表示的目录项的主键值不小于`320`，所以主键值为`20`的记录对应的目录项记录在`页30`中。

2、通过目录项记录页`确定用户记录真实所在的页`。

在一个存储`目录项记录`的页中通过主键值定位一条目录项记录的方式说过了。

3、在真实存储用户记录的页中定位到具体的记录。

#### ③迭代3次：目录项记录页的目录页

问题来了，在这个查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些`页是不连续的`，如果我们表中的数据非常多则会`产生很多存储目录项记录的页`，那我们怎么根据主键值快速定位一个存储目录项记录的页呢? 那就为这些存储目录项记录的页再生成一个`更高级的目录`，就像是一个多级目录一样，`大目录里嵌套小目录`，小目录里才是实际的数据，所以现在各个页的示意图就是这样子:
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127113956533-2027814988.png)

如图，我们生成了一个存储更高级目录项的`页33`，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在`[1，320)`之间，则到页30中查找更详细的目录项记录，如果主键值`不小于320`的话，就到页32中查找更详细的目录项记录。

随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：
![img](InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94.assets/1613668-20220127114001776-1049309650.png)

这个数据结构，它的名称是`B+树`

#### ④B+Tree

不论是存放`用户记录`的数据页，还是存放`目录项记录`的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为`节点`。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为`叶子节点`，其余用来存放`目录项`的节点称为`非叶子节点`或者`内节点`，其中B+树最上边的那个节点也称为`根节点`。

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第`0`层，之后依次往上加。之前我们做了一个非常极端的假设: 存放用户记录的页`最多存放3条记录`，存放目录项记录的页`最多存放4条记录`。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放`100条用户记录`，所有存放目录项记录的内节点代表的数据页可以存放`1000条目录项记录`，那么:

● 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。

● 如果B+树有2层，最多能存放1000×100=180008条记录。
● 如果B+树有3层，最多能存放1080×1080×100=100880000条记录。
● 如果B+树有4层，最多能存放1080×1000×1000×100=1000,0008,8080条记录。相当多的记录！！！

你的表里能存放`100000000000`条记录吗?所以一般情况下，我们`用到的B+树都不会超过4层`，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页)，又因为在每个页面内有所谓的`Page Directory`(页目录)，所以在页面内也可以通过`二分法`实现快速定位记录。





