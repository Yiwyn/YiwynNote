### MySQL数据结构选择的合理性



> ##### 从MySQL的角度来看，尽可能的减少I/O操作，所消耗的时间也会越小，磁盘的I/O操作次数对索引的使用效率至关重要。







### Hash结构

- ##### Hash本身是一个函数，又被称为散列函数，它可以帮助我们答复提升检索数据的效率

- ##### Hash算法是通过某种确定性的算法将输入转换为输出，<font color='red'>相同的输入永远会得到相同的输出</font>

##### 

#### 为什么索引结构设计成树型而不是Hash

- ##### Hash索引仅能满足=、<>、IN 查询，若要进行范围查询，则Hash索引会将时间复杂度退化到O(n)；而树形有序的特征，依然能保存O(Log2N)的高效率

- ##### Hash索引储存数据是无序的，当进行一些排序查询（ORDER BY）的情况下，使用Hash索引还需要对数据进行重新排序。

- ##### 对于联合索引的情况，Hash值是将联合索引的值合并在一起来计算的，无法单独对一个键或者几个索引进行查询。

- ##### 对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是索引列的值如果<font color='red'>重复很多</font>，效率就会降低。这是因为当遇到Hash冲突时，需要遍历桶中的行指针及逆行比较，查询查询的关键字，非常耗时。



#### Hash索引的适用性

- ##### Redis 存储的核心是Hash表

- ##### 等值查询可以采用Hash索引

- ##### InnoDB本身不支持Hash索引，但是提供<font color='red'>自适应Hash索引</font> 







### 二叉搜索树

- ##### 一个节点最多只能有两个子节点，也就是一个节点度不能超过2

- ##### 左子节点<本节点；右子节点>=本节点；比本节点大向右，比本节点小向左。



#### 极端场景：

- ##### 根节点是最大或者最小的值，这个时候二叉树搜索树会退化成为一条链表。查询数据的时间变成了O(n)。为了降低IO次数，引入了AVL树





### AVL树

- ##### 为了解决二叉搜索树在极端情况下退化为链表的情况，提出了<font color='red'>平衡二叉搜索树(Blanced Binary Tree)</font>，又称为AVL树。

- ##### 它是一棵空树或者它的左右两个子树的高度查的绝对值不会超过1，并且两个子树都是一颗平衡二叉树

  - ##### 平衡二叉树有很多种包括了 <font color='red'>平衡二叉搜索树、红黑树、数堆、伸展树</font>

- ##### 树的层次越低越好，树的层次决定了IO的次数





### B-Tree

- ##### B树 Blance Tree 即 <font color='red'>多路平衡查找树</font>。

- ##### 不同于二叉树的是，B树种每个节点存在多个数据。例如两个数据=>则 可以划分为 <font color='red'>小于左值 介于两值之家你 大于右值 </font>

- ##### 不同于索引的是，索引会将有效数据存放在叶子节点种，而B树的每个节点都会保存数据（父子节点不存在相同值）



